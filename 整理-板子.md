[TOC]

# 一些操作

## 语法

1.[,] 结构化绑定（structured binding）( C++17 or later!)

如果 `a` 是一个 `pair<int,pair<int,int>>` 类型的变量，那么可以使用 `auto [v,[t,x]]=a;` 这种形式的结构化绑定来分解它。这样，`v` 的值将等于 `a.first`，而 `t` 和 `x` 的值分别等于 `a.second.first` 和 `a.second.second`。在结构化绑定中，必须使用 `auto` 关键字来声明变量。这是因为结构化绑定实际上是创建了一个匿名结构体，并将其成员与您指定的变量名绑定在一起。由于结构体的类型是编译器自动生成的，因此您不能显式指定它的类型，只能使用 `auto` 关键字来进行类型推断。

2.int 宏定义成为了long long，可以用signed来代表int

3.重定向：

当使用 `freopen` 函数重定向标准输入时，它会影响所有从标准输入读取数据的函数，包括 `getchar`，`cin`。

```c++
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```

然后，当你使用 `getchar` 函数时，它会从 `input.txt` 文件中读取数据，而不是从标准输入读取。

```
cin.fail()为真则打开失败
```

## 字符串

1. 字符串常量被存储在静态存储区域中，并且其地址在编译时就已经确定了。因此，可以使用下标操作符（[]）访问字符串中的单个字符。当 << 左侧为一个输出流对象（如 std::cout），右侧为一个字符串常量（如 "\n"）时，C++ 中已经对该运算符进行了重载，使其可以输出字符串常量。所以可以：(并不是所有的常量都是指针，只有字符串常量是指针)

```cpp
for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)std::cout << a[j]<< " \n"[j == m - 1];//不用额外在大循环里换行了
```

## 函数

1. 四舍五入round()，取到整数，，，如果要保留1位小数可以先*10，round(),再/10。

2. int cnt = distance(st.begin(), st.upper_bound(x));找到容器中小于等于x数的个数（到首地址的距离），lower_bound就是小于了。

3. 快读快写：

```
inline ll read()
{
    ll x = 0, z = 1;
    char c = getchar();
    while (!isdigit(c))
    {
        if (c == '-')z = -1;
        c = getchar();
    }
    while (isdigit(c))
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return z * x;
}
inline void writ(ll x)
{
    if (x < 0)
    {
        putchar('-');
        x = (~x) + 1;
    }
    if (x > 9)
        writ(x / 10);
    putchar(x - x / 10 * 10 + 48);
}
```

4. unique：去除容器中相邻的重复元素。

5. nth_element：按指定范围进行分类，即找出序列中第 大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)。

   比如：nth_element(vec.begin(),vec.begin()+m,vec.end());

6. next_permutation：将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 false 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 true。next_permutation(v.begin(), v.end()) 或 next_permutation(v + begin, v + end)。

## 容器

1.可以从尾遍历到头（auto i = a.rbegin(); i != a.rend(); ++i）

2.priority_queue默认大根堆

```
Syntax 1: Max-heap priority queue of tuples:
priority_queue<tuple<data_type1, data_type2, data_type3>> priorityQueue;

Syntax 2: Min-heap priority queue of tuples:
priority_queue<tuple<data_type1, data_type2, data_type3>, 
vector<tuple<data_type1, data_type2, data_type3>>, 
greater<tuple<data_type1, data_type2, data_type3>>> priorityQueue;


Syntax 3: Customized priority queue of tuples (using comparator):
struct comparator 
{
  int operator()(const tuple<int, int, string>& tuple1,const tuple<int, int,  string>& tuple2)
  {
    // Second element of tuples is equal
    if (get<1>(tuple1) == get<1>(tuple2)) 
    {
      if (get<0>(tuple1) == get<0>(tuple2)) 
      {
        if (get<2>(tuple1) >= get<2>(tuple2))
          return true;
    	return false;
      }
      return get<0>(tuple1) >= get<0>(tuple2);
    }  
    return get<1>(tuple1) >= get<1>(tuple2);
  }
};
priority_queue<tuple<data_type1, data_type2, data_type3>, 
vector<tuple<data_type1, data_type2, data_type3>>, comparator> priorityQueue;
```

3.`std::make_tuple(p,l,r)` 会创建一个新的 `std::tuple` 对象，它包含三个元素 `p`，`l` 和 `r` 的副本。但是这个语句并不会改变 `p`，`l` 和 `r` 的值。

如果您想从一个 `std::tuple` 对象中提取值并赋值给变量，可以使用 `std::tie` 函数。例如，如果 `pq.top()` 返回一个包含三个元素的 `std::tuple` 对象，您可以使用以下语句来给 `p`, `l`, 和 `r` 赋值：

```c++
std::tie(p, l, r) = pq.top();
```

# 图论

## 链式前向星

邻接表的存法，空间更优，而且容易找到反边(存在相邻位置，第一个放偶数位置，反边在$i\oplus 1$)

```cpp
int head[N],to[N],Next[N],cnt=0;
void init(){
    for (int i = 0; i < N; i++)
        head[i]=Next[i]=-1;
}

void add(int u,int v,int w){
    to[cnt]=v;
    //链表的头插法
    Next[cnt]=head[u];
    head[u]=cnt++;
}
```

## 拓扑排序

```cpp
vector<int> toposort(const vector<vector<int>>&to)//参数为图(不包含节点0)，返回topo排序顺序
{
    int n=to.size();
    vector<int>in(n);
    for (int i = 1; i < n; i++)
        for (auto k:to[i]){assert(k<n);in[k]++;}
    
    vector<int>topo;

    queue<int>q;
    for (int i = 1; i < n; i++)
    {
        if(!in[i])q.push(i);
    }
    
    while(!q.empty()){
        int u=q.front();
        topo.push_back(u);
        q.pop();

        for (auto v:to[u])
        {
            in[v]--;
            if(!in[v])q.push(v);
        }
    }
    assert(topo.size()==n-1);//拓扑排序失败，有环
    return topo;
}
```

## 最短路

### Floyd

全源，可以有负边，但不能有负环

```cpp
void floyd(vector<vector<int>>&mp)//注意mp初始化应该是无穷，自边一般是0
{
    int n=mp.size()-1;
    for (int k = 1; k <= n; k++)
        for (int x = 1; x <= n; x++)
            for (int y = 1; y <= n; y++)
                mp[x][y]=min(mp[x][y],mp[x][k]+mp[k][y]);
    return;
}
```

### Dijkstra

单源，因为贪心不能有负边

```cpp
vector<int> dijkstra(const vector<vector<pair<int,int>>>&to,int s)//参数是图（to的first是终点，second是距离）和起点，返回起点到其他点的最短距离
{
    int n=to.size();
    vector<int>dist(n,inf);
    vector<int>st(n,0);

    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;//first是值，second是序号

    dist[s]=0;
    q.push({0,s});

    while(!q.empty()){
        int u=q.top().second;
        q.pop();
        if(st[u])continue;
        st[u]=1;

        for (auto e:to[u])
        {
            int v=e.first,w=e.second;
            if(dist[u]+w<dist[v]){
                dist[v]=dist[u]+w;
                q.push({dist[v],v});
            }
        }
    }
    return dist;
}
```

### Bellman_Ford

单源，可以负边，不能有负环

```cpp
vector<int> bellman_ford(const vector<vector<pair<int,int>>>&to,int s)
{
    int n=to.size();
    vector<int>dist(n,inf);
    dist[s]=0;

    for (int k = 1; k < n; k++)
    {
        for (int u = 1; u < n; u++)
        {
            for(auto e:to[u]){
                int v=e.first,w=e.second;
                dist[v]=min(dist[v],dist[u]+w);
            }
        }
    }
    
    return dist;
}
```

### SPFA（Shortest Path Faster Algorithm）

单源，可以负边，不能有负环，Bellman_Ford的队列优化，可以用来检测负环

```cpp
vector<int> SPFA(const vector<vector<pair<int,int>>>&to,int s)//参数是图（to的first是终点，second是距离）和起点，返回起点到其他点的最短距离
{
    int n=to.size();
    vector<int>dist(n,inf);
    vector<bool>vis(n,0);//是否在队列中
    vector<int>cnt(n,0);

    vis[s] = true;
    dist[s]=0;
    
    queue<int>q;
    q.push(s);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        cnt[u]++;
        assert(cnt[u]<=n);//否则有负环

        for (auto e : to[u]) {
            int v = e.first, w = e.second;
            if (dist[v] > dist[u] + w){
                dist[v] = dist[u] + w;
                if (!vis[v]) {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    return dist;
}
```

### Johnson

全源，可以负边，不能有负环

先求一遍最短路$f[ ]$，那么$w_{u,v}+f_u \geq f_v $,那么$w_{u,v}+f_u -f_v\geq 0$

我们把边权换成了$w'_{u,v}=w_{u,v}+f_u -f_v$

$dist′=weight(u,v_1)+f[u]−f[v_1]+...+weight(v_n,v)+f[v_n]−f[v]$

​		$=weight(u,v_1)+weight(v_1,v_2)+...+weight(v_n,v)+f[u]−f[v]$

​		$=dist+f[u]−f[v]$

$f[u]-f[v]$是只与起点、终点有关的常数，求的是$(W_{i,j}+f[i]-f[j])$的最小值，就是原来的路径。

为了让图连通，我们加入一个超级源点求$f[]$，我们用SPFA,然后在原图上求n次Dijkstra,复杂度$O(nm+n^2logm)$。

```cpp
vector<vector<int>> johnson(const vector<vector<pair<int,int>>>&to)//参数是图（to的first是终点，second是距离）和起点,返回mp
{
    int n=to.size();

    //建立超级源点
    for (int i = 0; i < n; i++)
        to[0].push_back({i,0});
    vector<int>f=SPFA(to,0);
    
    //去掉超级源点
    to[0].clear();

    //更新路径权值
    for (int u = 1; u < n; u++)
        for (auto &e:to[u])//引用哟！
            e.second+=f[u]-f[e.first];

    vector<vector<int>>mp(n);

    for (int u = 1; u < n; u++)
    {
        mp[u]=dijkstra(to,u);
        for (int v = 1; v < n; v++)
            if(mp[u][v]!=inf)mp[u][v]-=f[u]-f[v];//如果不存在边就不修正；
    }
    
    return mp;
} 
```

## tarjan缩点

没有去除重边

```cpp
void tarjan(vector<vector<int>> &to, vector<int> &val) // 原来的图，和点的值
{
    int n = to.size(), tot = 0;

    vector<int> dfn(n), low(n);
    stack<int> scc;     // 是否在当前（可能的）强连通里
    vector<bool> st(n); // 对应的标记
    vector<int>belong(n);//属于哪个scc

    int cnt = 0;
    function<void(int)> dfs = [&](int u)
    {
        dfn[u] = low[u] = ++cnt;
        scc.push(u);
        st[u] = 1;
        for (auto v : to[u])
            if (!dfn[v])
                dfs(v);

        for (auto v : to[u])
            if (st[v])
                low[u] = min(low[u], low[v]);

        if (dfn[u] == low[u])//弹出一个scc
        {
            tot++;
            while (dfn[scc.top()] != dfn[u])
            {
                belong[scc.top()]=tot;
                st[scc.top()] = 0;
                scc.pop();
            }
            belong[scc.top()]=tot;
            st[scc.top()] = 0;
            scc.pop();
        }
    };

    for (int i = 1; i < n; i++)
        if (!dfn[i])dfs(i);
    
    
    vector<vector<int>> to_temp(tot+1);
    vector<int> val_temp(tot+1);
    for (int i = 1; i < n; i++)
    {
        val_temp[belong[i]]+=val[i];
        for (auto v:to[i])
        {
            if(belong[i]!=belong[v])to_temp[belong[i]].push_back(belong[v]);//没有去重边，因为一定比原来的少，没必要
        }
    }
    to.swap(to_temp);
    val.swap(val_temp);
}
```

## 最大流

### Edmonds_Karp

用bfs不断的找增广路径，每次bfs的复杂度$O(m)$,据说最多找$O(nm)$次，所以复杂度$O(nm^2)$,因为边一般很大，解决的问题$n$范围小，索性用邻接矩阵存图

```cpp
ll Edmonds_Karp(vector<vector<ll>>&mp,int s,int t){
    ll maxflow=0;
    int n=mp.size();

    vector<int>pre(n);//记录路径:前驱
    vector<ll>flow(n);//在bfs可以重复利用
    auto bfs=[&](int s,int t){
        pre.assign(n,-1);
        flow[s]=inf,flow[t]=0;
        queue<int>q;
        q.push(s);
        while(!q.empty()){
            int u=q.front();q.pop();
            if(u==t)break;
            for (int i = 1; i < n; i++)
            {
                if(i!=s&&mp[u][i]>0&&pre[i]==-1){
                    pre[i]=u;
                    q.push(i);
                    flow[i]=min(flow[u],mp[u][i]);
                }
            }
        }
        if(pre[t]==-1)return -1LL; 
        return flow[t];
    };
    
    while(1){
        ll flow=bfs(s,t);
        if(flow==-1)break;//没找到增广路
        
        //更新残留网络，正向减边，反向加边
        int pos=t;
        while(pos!=s){
            mp[pre[pos]][pos]-=flow;
            mp[pos][pre[pos]]+=flow;
            pos=pre[pos];
        }
        maxflow+=flow;        
    }
    return maxflow;
}
```

​                                                                                                                                                                                                                                       

## LCA

### 倍增法

```cpp
const int maxsize=19;//树的最大层数的二进制位数+1

vector<bool> vis;
vector<int> deep;
vector<vector<int>> to;
vector<vector<int>> fa;
void dfs(int pos, int d)
{
    vis[pos] = true;
    deep[pos] = d;
    for (int i = 1; i < maxsize; i++)
    {
        fa[pos][i] = fa[fa[pos][i - 1]][i - 1];
    }

    for (int i = 0; i < to[pos].size(); i++)
    {
        if (vis[to[pos][i]])
            continue;
        fa[to[pos][i]][0] = pos;
        dfs(to[pos][i], d + 1);
    }
}

int lca(int v, int u)
{

    if (v != u)
    {
        if (deep[v] < deep[u])
            swap(v, u); // v是深的 

        if (deep[v] != deep[u])
        {
            for (int i = maxsize-1; i >= 0; i--)
            {
                if (deep[fa[v][i]] > deep[u])
                {
                    v = fa[v][i];
                }
            }
            v = fa[v][0];
        } // deep相同

        if (v == u)
            return v;
        for (int i = maxsize-1; i >= 0; i--)
        {
            if (fa[v][i] != fa[u][i])
            {
                v = fa[v][i];
                u = fa[u][i];
            }
        }
        return fa[v][0];
    }
    return v;
}

int main(int argc, char *argv[])
{
    ll n, m, s;
    cin >> n >> m >> s;
    to.assign(n + 1, vector<int>());
    fa.assign(n + 1, vector<int>(maxsize));
    deep.assign(n + 1, 0);
    vis.assign(n + 1, 0);

    for (int i = 1; i < n; i++)
    {
        int x = read(), y = read();
        to[x].push_back(y);
        to[y].push_back(x);
    }

    dfs(s, 1); // 遍历树
    for (int i = 0; i < m; i++)
    {
        int a = read(), b = read();
        cout << lca(a, b) << endl;
    }
    return 0;
}
```

# 数据结构

## 并查集

```cpp
        vector<int>fa(n+1);
        iota(fa.begin(),fa.end(),0);
        function<int(int)> find=[&](int x){
            if(fa[x]!=x)fa[x]=find(fa[x]);
            return fa[x];
        };
        auto merge=[&](int a,int b){
            a=find(a),b=find(b);
            if(a!=b)fa[a]=fa[b];
        };
```

## 树状数组

```cpp
	#define lowbit(x) (x&-x)
    vector<int>tr(n+1);//tr[x]表示[x-lowbit(x)+1,x]的区间和,tr[x]的父亲是tr[x+lowbit(x)]
    auto update=[&](int x,int y){
        for(;x<=n;x+=lowbit(x))
            tr[x]+=y;       
    };
    auto query=[&](int x){//求x的前缀
        int base=0;
        for(;x;x-=lowbit(x))
            base+=tr[x];
        return base;
    };
```

## 主席树

logn求区间第k小值，用权值线段树 和 前缀和差分的原理，每插入一个数，更新一个权值线段树的版本，前后版本的差值就是区间的权值线段树，再在权值线段树上找到第k小值

```cpp
struct {
    int lc,rc,dat;
}sgtree[N<<5];
int cnt;

int getid(vector<int>&b,int x){
    return lower_bound(b.begin(), b.end(),x)-b.begin()+1;
}

int build(int l,int r){
    int pos=cnt++;
    if(l==r)return pos;
    int mid=(l+r)>>1;
    sgtree[pos].lc=build(l,mid);
    sgtree[pos].rc=build(mid+1,r);
    return pos;
}

int updata(int pre,int l,int r,int x){
    int rt=cnt++;
    sgtree[rt]=sgtree[pre];
    sgtree[rt].dat++;
    if(l==r)return rt;
    int mid=(l+r)>>1;
    if(x<=mid)sgtree[rt].lc=updata(sgtree[pre].lc,l,mid,x);
    else sgtree[rt].rc=updata(sgtree[pre].rc,mid+1,r,x);
    return rt;
}

int query(int u,int v,int l,int r,int k){
    if(l==r)return l;

    int x=sgtree[sgtree[v].lc].dat-sgtree[sgtree[u].lc].dat;//右边界版本左子树的值减左边界版本左子树的值
    int mid=(l+r)>>1;
    if(x<k)return query(sgtree[u].rc,sgtree[v].rc,mid+1,r,k-x);
    else return query(sgtree[u].lc,sgtree[v].lc,l,mid,k);
}

int root[N];//不同版本权值线段树的根
int main()
{
    int n=read(),m=read();
    vector<int>a(n),b(n);
    for (int i = 0; i < n; ++i) {
        a[i]=read();
    }
    //离散化
    b=a;
    sort(b.begin(),b.end());
    b.erase(unique(b.begin(), b.end()),b.end());
    int num=b.size();
    
    root[0]=build(1,num);
    for (int i = 1; i <= n; ++i) {
        root[i]=updata(root[i-1],1,m, getid(b,a[i-1]));
    }

    for (int i = 0; i < m; ++i) {
        int l=read(),r=read(),k=read();
        cout<<b[query(root[l-1],root[r],1,m,k)-1]<<endl;
    }
}
```

## st表（Sparse Table，稀疏表）

用于解决 **可重复贡献问题** 的数据结构，就是一个区间重复计算不影响结果，比如max

用倍增的思想预处理$O(n\log n)$表，如果按倍增的不重复覆盖的区间的加法复杂度$O(\log n)$,预处理的常数还不如线段树。

因为区间可覆盖，可以用两个大区间,长度是$2^{\log{(r-l)}}$覆盖线段$O(1)$



预处理：令$f(i,j)=max[i,i+2^j-1]$,因为最小的区间是max[i,i]=i;

```
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long

inline ll read() {ll x = 0, z = 1;char c = getchar();while (!isdigit(c)) {if (c == '-')z = -1;c = getchar();}while (isdigit(c)) {x = (x << 1) + (x << 3) + (c ^ 48);c = getchar();}return z * x;}
inline void writ(ll x){if(x<0) {putchar('-');x=(~x)+1;}if(x>9)writ(x/10);putchar(x-x/10*10+48);}

//区间最大值
int main(){
    int n=read(),m=read();
    vector<int>a(n+1);
    for (int i = 1; i <= n; i++)
    {
        a[i]=read();
    }
    
    int maxbit=log2(n);
    //预处理，和倍增法求lca一样，然后dp转移，dp[i][j]表示区间[i,i+2^j-1]内最大值，dp[i][j]=max(dp[i][j-1],dp[i+2^(j-1)][j-1]);

    //（i,j）依赖于（i,j-1）和（i+2^(j-1),j-1）,考虑边界，j=0的时候区间里就i本身，i+2^(j-1)大于n没有意义，可以不考虑，或者假设是用负无穷填充，不影响结果。(可以直接考虑i+2^j-1<=n)
    vector<vector<int>>st(n+1,vector<int>(cnt,-inf));

    for (int i = n; i >= 1; i--)
    {
        for (int j = 0; j <= maxbit; j++)
        {
            if(!j)st[i][j]=a[i];
            else if(i+(1<<j)-1<=n)st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
    
    //O(1)查询
    while (m--)
    {
        int l=read(),r=read();
        int s=log2(r-l+1);
        printf("%d\n",max(st[l][s],st[r-(1<<s)+1][s]));
    }
}
```

**经典错误就是边界多或少了个等号，多或少了个减一**

# 数论

## 离散化

### 离散化数组

```cpp
std::sort(a + 1, a + 1 + n);
 len = std::unique(a + 1, a + n + 1) - a - 1;
// 离散化整个数组的同时求出离散化后本质不同数的个数。
for (int i = 0; i < n; ++i)
b[i]=std::lower_bound(a + 1, a + len + 1, x) - a;  // 查询 x 离散化后对应的编号
```

### vector 进行离散化

```cpp
// std::vector<int> a, b; // b 是 a 的一个副本 
std::sort(a.begin(), a.end());
a.erase(std::unique(a.begin(), a.end()), a.end());
 for (int i = 0; i < n; ++i)   b[i] = std::lower_bound(a.begin(), a.end(), b[i]) - a.begin();
```

## 逆元

### 费马小定理

若存在整数 $a , p$ 且$gcd(a，p)=1$,即二者互质

有：$a^{(p−1)}≡1(\mod p)$

```
ll fpw(ll a,ll n,ll mod){
	ll ans=1;
	ll m=a;
	while(n){
		if(n&1){
			ans=ans*m%mod;
		}
		n>>=1;
		m=m*m%mod;
	}
	return ans;
}


ll inv(ll n, ll mod) {
    return fpw(n, mod - 2, mod);
}
```

### 拓展欧几里得

```
int ex_gcd(int a, int b, int &x, int &y) {  // 函数返回gcd(a, b)
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int r = ex_gcd(b, a % b, y, x);
    y -= (a / b) * x;
    return r;
}
 
int main() {
    int a, b, x, y;
    cin >> a >> b;  // 求a关于模b的逆元
    cout << (ex_gcd(a, b, x, y) == 1 ? (x % b + b) % b : -1) << endl;  // -1表示逆元不存在
    return 0;
}
```

### 线性求逆元

```
inv[1] = 1;
for (int i = 2; i <= n; i++) {
   inv[i] = (ll)(p - p / i) * inv[p % i] % p;
}
```

### 线性求n个数的逆元

复杂度$O(n + \log p)$

```
//a数组是要求的数组
s[0] = 1;
for (int i = 1; i <= n; ++i) s[i] = s[i - 1] * a[i] % p;
sv[n] = qpow(s[n], p - 2);
// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.
for (int i = n; i >= 1; --i) sv[i - 1] = sv[i] * a[i] % p;
for (int i = 1; i <= n; ++i) inv[i] = sv[i] * s[i - 1] % p;
```

## 线性基

```cpp
	vector<ll> d(64); // 基底
    auto add = [&](ll x)
    {
        for (int i = 60; i >= 0; i--)
            if (x & (1ll << i)) // 注意，如果i大于31，前面的1的后面一定要加ll
            {
                if (d[i])
                    x ^= d[i];
                else
                {
                    d[i] = x;
                    return; // 插入成功就退出
                }
            }
    };
    auto mx_xor = [&](ll anss = 0)
    {
        for (int i = 60; i >= 0; i--) // 记得从线性基的最高位开始
            if ((anss ^ d[i]) > anss)
                anss ^= d[i];
        return anss;
    };
    auto mi_xor = [&](ll anss = 0)
    {
        for (int i = 60; i >= 0; i--)
            if ((anss ^ d[i]) < anss)
                anss ^= d[i];
        return anss;
    };
    auto kth_mi_xor = [&](int k) // 第k小的异或值,从0开始
    {
        ll anss = 0;
        for (int i = 0; i <= 60; i++)
            if (d[i])
            {
                if (k & 1)
                    anss ^= d[i];
                k >>= 1;
            }
        return anss;
    };
```

## 二分、三分

```cpp
// 整数二分的模板代码
int binarySearch(int a[], int l, int r, int x) {
    while(l <= r) {
        int mid = l + (r - l) / 2;
        if(a[mid] == x) return mid;
        else if(a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return a[l];
}
```

```cpp
// 整数三分的模板代码
int ternarySearch(int l, int r) {
    while(l < r) {
        int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;
        if(f(mid1) < f(mid2)) l = mid1 + 1;//凸
        else r = mid2 - 1;
    }
    return f(l);
}
```

```cpp
// 三分算法的模板代码
double ternarySearch(double l, double r) {
    while(fabs(r - l) > eps) {
        double mid1 = l + (r - l) / 3.0;
        double mid2 = r - (r - l) / 3.0;
        if(f(mid1) < f(mid2)) l = mid1;//凸
        else r = mid2;
    }
    return f(l);
}
```

条件苛刻，比如：$f(b) = b - 1 + \lceil \frac{n}{b} \rceil + \lceil \frac{m}{b} \rceil$就不可以，然后可以试试硬试取最小值。如果是只有小凸起，大致单调性一样，可以用区间的最小值三分，抹平凸起。

## 最大公约数、最小公倍数、快速幂

### 最大公约数

```c++
int gcd(int a,int b){
 	return b?gcd(b,a%b):a;
}
```

### 最小公倍数

```c++
int lcm(int a, int b) {
    return a*b / gcd(a,b);
}
```

### 快速幂

(Fast Powering Method)

```
ll fpw(ll a,ll n,ll mod){
	ll ans=1;
	ll m=a;
	while(n){
		if(n&1){
			ans=ans*m%mod;
		}
		n>>=1;
		m=m*m%mod;
	}
	return ans;
}
```

## 扩展欧几里得

用于求解满足 ax+by=gcd(a,b) 的一组整数解 (x,y)

```
int x,y;
int exgcd(int a,int b,int &x,int &y){
  if(!b){
	x=1;
    y=0;
    return a;
  }
  int d=exgcd(b,a%b,x,y);
  int t=x;
  x=y;
  y=t-(a/b)*y;
  return d;
}	
```

```
//矩阵的迭代
int exgcd(int a, int b, int &x, int &y) {
 int x1 = 1, x2 = 0, x3 = 0, x4 = 1;
 while (b != 0) {
  int c = a / b;
  std::tie(x1, x2, x3, x4, a, b) =
  std::make_tuple(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c);
 }
 x = x1, y = x2;
 return a;
}
```

##         fft、ntt加速求多项式乘积

###              fft

（复杂度*O*(nlogn),但需要浮点运算,有误差，不能取模）

​	fft用n次单位复数的n个根的消去、折半、求和引理的性质、用分治的方法求多项式的点值表达;

​	ifft只用交换**a**和**y**，用wn_inv来代替wn，然后用fft结果除n,把点值表达转换为多项式；

```c++
#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
using namespace std;

// 定义复数类型
typedef complex<double> Complex;

// 定义pi
const double PI = acos(-1.0);

// 计算w^n
Complex wn(int n)
{
    return Complex(cos(2 * PI / n), sin(2 * PI / n));
}

// 计算w^-n
Complex wn_inv(int n)
{
    return Complex(cos(-2 * PI / n), sin(-2 * PI / n));
}

// 计算二进制逆序
int reverse(int x, int len)
{
    int res = 0;
    for (int i = 0; i < len; i++)
    {
        res = (res << 1) | (x & 1);
        x >>= 1;
    }
    return res;
}

// 快速傅里叶变换，将多项式从系数表示转换为点值表示
void fft(vector<Complex> &a, int n)
{
    // 将系数按照二进制逆序重新排列，方便分治处理
    for (int i = 0; i < n; i++)
    {
        int j = reverse(i, (int)log2(n));
        if (i < j)
            swap(a[i], a[j]);
    }
    // 从长度为2的子问题开始合并，直到长度为n的整个问题
    for (int len = 2; len <= n; len <<= 1)
    {
        // 计算单位根w^(n/len)
        Complex w = wn(len);
        // 遍历每个子问题的起点i，步长为len
        for (int i = 0; i < n; i += len)
        {
            // 初始化旋转因子为1
            Complex rot = 1;
            // 遍历每个子问题的前半部分j，与后半部分j+len/2进行合并
            for (int j = i; j < i + len / 2; j++)
            {
                // 计算奇数项和偶数项
                Complex odd = a[j + len / 2] * rot;
                Complex even = a[j];
                // 合并结果为新的偶数项和奇数项
                a[j] = even + odd;
                a[j + len / 2] = even - odd;
                // 更新旋转因子为下一个单位根的幂次
                rot *= w;
            }
        }
    }
}

// 快速傅里叶逆变换，将多项式从点值表示转换为系数表示，并除以n取整得到最终结果
void ifft(vector<Complex> &a, int n)
{
    // 将系数按照二进制逆序重新排列，方便分治处理（与fft相同）
    for (int i = 0; i < n; i++)
    {
        int j = reverse(i, (int)log2(n));
        if (i < j)
            swap(a[i], a[j]);
    }

    // 从长度为2的子问题开始合并，直到长度为n的整个问题（与fft相同）
    for (int len = 2; len <= n; len <<= 1)
    {
        // 计算单位根w^-(n/len)
        Complex w = wn_inv(len);
        // 遍历每个子问题的起点i，步长为len（与fft相同）
        for (int i = 0; i < n; i += len)
        {
            // 初始化旋转因子为1（与fft相同）
            Complex rot = 1;
            // 遍历每个子问题的前半部分j，与后半部分j+len/2进行合并（与fft相同）
            for (int j = i; j < i + len / 2; j++)
            {
                // 计算奇数项和偶数项（与fft相同）
                Complex odd = a[j + len / 2] * rot;
                Complex even = a[j];
                // 合并结果为新的偶数项和奇数项（与fft相同）
                a[j] = even + odd;
                a[j + len / 2] = even - odd;
                // 更新旋转因子为下一个单位根的幂次（与fft相同）
                rot *= w;
            }
        }
    }
    // 除以n取整得到最终结果
    for (int i = 0; i < n; i++)
    {
        a[i] /= n;
        a[i] = Complex(round(a[i].real()), round(a[i].imag()));
    }
}

// 多项式乘法，使用fft算法加速
vector<Complex> multiply(vector<Complex> &a, vector<Complex> &b)
{
    // 计算两个多项式的最大次数
    int deg_a = a.size() - 1;
    int deg_b = b.size() - 1;

    // 计算乘积多项式的最大次数
    int deg_c = deg_a + deg_b;

    // 计算需要的点数，必须是2的幂次
    int n = 1;
    while (n <= deg_c)
        n <<= 1;

    // 扩展两个多项式到n个点，并转换为点值表示
    a.resize(n); // 从设置vector大小
    b.resize(n);

    fft(a, n);
    fft(b, n);

    // 计算乘积多项式的点值表示，即两个多项式的点值表示对应位置相乘
    vector<Complex> c(n);

    for (int i = 0; i < n; i++)
    {
        c[i] = a[i] * b[i];
    }

    // 转换回系数表示，并除以n取整得到最终结果
    ifft(c, n);

    return c;
}

// 主函数，测试样例 (x+1)(x-1) = x^2 - 1
int main()
{
   vector<Complex> a{1,2,3};  // a系数表示
    vector<Complex> b{4,5,6}; // b数表示

    vector<Complex> c = multiply(a, b); // (x+1)(x-1) 的系数表示

    for (int i = 0; i < c.size(); i++)
    {
        cout << c[i].real() << " "; // 输出系数，忽略虚部（应该为0）
    }

    cout << endl;

    return 0;
}
```

### ntt

（用具有同样性质的原根来代替复数根，复杂度*O*(nlogn)，不用浮点运算，可以取模）//这个板子会改变原来的a,b;

```c++
#include <iostream>
#include <fstream>
#include <set>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <utility>
#include <map>
#include <string.h>
#include <cmath>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#define ll long long
#define inf 0x3f3f3f3f
using namespace std;

const int maxn=10000;//最长数组，足够长就行；

namespace NTT // NTT 命名空间
{
    const int p = 998244353, g = 3; // 模数和原根
    int w[maxn << 2], inv[maxn << 2], r[maxn << 2], last=0; // 变换系数，逆元，置换数组，上一次变换的长度
    int mod(int x) { return x >= p ? x - p : x; } // 取模函数
    ll qp(ll base, ll n) // 快速幂函数
    {
        base %= p;
        ll res = 1;
        while (n) {
            if (n & 1) (res *= base) %= p;
            (base *= base) %= p;
            n >>= 1;
        }
        return res;
    }

    void init() // 初始化函数，预处理逆元和变换系数
    {
        int lim = maxn << 1; // 数组最大长度的两倍
        inv[1] = 1;
        for (int i = 2; i <= lim; i++) inv[i] = mod(p - 1ll * (p / i) * inv[p % i] % p); // 预处理逆元
        for (int i = 1; i < lim; i <<= 1) // 预处理变换系数
        {
            int wn = qp(g, (p - 1) / (i << 1)); // 求出 (p-1)/(2*i) 次方根
            for (int j = 0, ww = 1; j < i; j++, ww = 1ll * ww * wn % p) w[i + j] = ww; // 求出变换系数
        }
    }
    
    void ntt(vector<int> &f, int n, int op) // 快速傅里叶变换
    {
        if (last != n) // 如果这一次的变换长度不同于上一次的长度，则需要重新计算置换数组
        {
            for (int i = 1; i < n; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0); // 计算置换数组
            last = n; // 更新上一次的变换长度
        }
        for (int i = 1; i < n; i++) if (i < r[i]) swap(f[i], f[r[i]]); // 通过置换数组进行位逆序置换
        for (int i = 1; i < n; i <<= 1) // 递归进行蝴蝶操作
            for (int j = 0; j < n; j += i << 1) // 第一层循环枚举分组的起始位置
                for (int k = 0; k < i; k++) // 第二层循环枚举分组内的元素
                {
                    int x=f[j+k],y=1ll*f[i+j+k]*w[i+k]%p; // 蝴蝶操作
                    f[j+k]=mod(x+y);f[i+j+k]=mod(x-y+p); // 更新值
                }
    
        if(op==-1) // 如果是逆变换，进行后续操作
        {
            reverse(&f[1],&f[n]); // 翻转数组
            for(int i=0;i<n;i++)f[i]=1ll*f[i]*inv[n]%p; // 乘上逆元
        }
    }

}

using NTT::ntt; // 使用NTT函数

vector<int> multiply(vector<int> &a, vector<int> &b)
{
    // 计算两个多项式的最大次数
    int deg_a = a.size() - 1;
    int deg_b = b.size() - 1;

    // 计算乘积多项式的最大次数
    int deg_c = deg_a + deg_b;
    
    // 计算需要的点数，必须是2的幂次
    int n = 1;
    while (n <= deg_c)
        n <<= 1;
    
    a.resize(n);
    b.resize(n);
    
    ntt(a, n,0);
    
    ntt(b, n,0);
    
    vector<int> c(n);
    
    for (int i = 0; i < n; i++)
    {
        c[i] =1ll *a[i] * b[i]%NTT::p;
    }
      
    // 转换回系数表示，并除以n取整得到最终结果
    ntt(c, n,-1);
    
    return c;

}

int main(int argc, char *argv[])
{
    //ios::sync_with_stdio(false);
    //cin.tie(0);

    vector<int> a{1,2,3};  // 系数表示
    vector<int> b{4,5,6}; //  系数表示
    NTT::init();//记得初始化
    
    vector<int> c = multiply(a, b); // 的系数表示
   
    for (int i = 0; i < c.size(); i++)
    {
        cout << c[i]<< " "; // 输出系数
    }
    return 0;
}
```

## 马尔科夫链

用于描述状态序列的转移过程。它基于一个假设：在给定当前状态下，未来的状态只与当前状态相关，而与过去状态无关。

表示初始状态，列出转移的概率，做矩阵的乘法。

```
void matrixMultiply(vector<double> &A, vector<vector<double>> &B)
{
    int n = B.size();
    vector<double> result(n, 0);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            result[i] += A[j] * B[j][i];
        }
    }
    result.swap(A);
    return;
}
```

# 博弈论

## SG函数和SG定理

### SG函数

在一个存在必输局面和必赢局面策略游戏里，局面构成一个有向图，无后继的一定是必输局面，它的SG函数值为0

设状态$x$有$k$个后继状态$y_1,y_2,...,y_k$.
$$
SG(x)=mex(SG(y_1),SG(y_2),...,SG(y_k))
$$


SG大于0的是必胜局面。

### SG定理

有$n$个有向图组合的游戏，最后不能走的失败。

当$SG(s_1)\oplus SG(s_2)\oplus ...\oplus SG(s_n)\neq 0$先手必胜。

多堆的$SG(s)=SG(s_1)\oplus SG(s_2)\oplus ...\oplus SG(s_n)$

证明可以映射Nim博弈（一个$SG=k$ 的状态，必然能转移到$SG=j$  $( 0 < j < k )$ 的状态),先手一定可以一步操作让异或值为$0$

## Nim博弈

描述：有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，每次至少取一个，无上限，最后取光者得胜利（不能操作失败）。

$SG(0)=0,SG(1)=1,SG(2)=mex(0,1)=2,...,SG(x)=x$

所以$SG(s_1)\oplus SG(s_2)\oplus ...\oplus SG(s_n)\neq 0$则先手胜利

## Bash博弈

描述：一堆n个物品，2个人从中轮流取，每次至少取p个，最多取m个(p<m)，最后取光着胜利（不能操作失败）。

有必胜法：$n=(m+p)*r$，时，先手取$x$个，后手取$(m+p)-x$个，保证先手不能取完。

所以当$n>m$时，$n\%(m+p)=0$，先手必败

## Wythoff博弈

描述：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

```cpp
bool f(int a,int b){
    if(a>b) swap(a,b);      //使得a小于b
    int temp=floor((b-a)*(1+sqrt(5.0))/2.0);
    if(temp==a)
        return 0;
    else 
        return 1;
}
```

# 字符串

## kmp

**利用模式串相等的前后缀（模式串的索引变到最大相等的前缀位置，相当于相等的后缀已经判断过了）**，保证文本串的的索引不回退，模式串索引只会和文本串一起增加，复杂度$O(n+m)$。

```
void getNext(vector<int> & next, const string &P){
	int j = 0; // 与当前后缀相同的前缀下标
	next[0] = 0;
	for (int i = 1; i < P.size(); ++i) {
		while (j > 0 && P[i] != P[j]) { 
			j = next[j - 1]; 
		}
		if (P[i] == P[j]) { 
			++j;
		}
		next[i] = j;
	}
}

int KMP(const string & P, const string & T) {
	//T为文本串，P模式串
	if (P.size() == 0) return 0;
	//最长相同前后缀表
	vector<int> next(P.size());
	getNext(next, P);
	int j = 0;   
	for (int i = 0; i < T.size(); ++i) {
		while (j > 0 && T[i] != P[j]) {
			j = next[j - 1];
		}
		if (T[i] == P[j]) {
			++j;
		}
		//当j等于自身长度说明匹配完成
		if (j == P.size()) {
		//此时i是匹配成功的最后一个位置，因此起始位置为 i -j + 1的位置
			return (i -j + 1);
		}
	}
	return -1;
}
```

## manachar

**利用遍历过的回文串对称避免重复判断**，边界不断拓展，复杂度$O(n)$

```cpp
vector<int> manachar(string& s){
    string ss="$#";//保证不越界
    for (int i = 0; i < s.size(); i++)
    {
        ss.push_back(s[i]);
        ss.push_back('#');
    }
    ss.push_back('&');//保证不越界

    vector<int>p(ss.size());//里面存以i为中心的回文半径
    int R=0,C;//边界(未到达) 和 边界回文子串的中心
    for (int i = 0; i < ss.size(); i++)
    {
        if(i<R) p[i]=min(R-i,p[C-(i-C)]);//中心位置对称点的p[i]已经求过了
        else p[i]=1;

        while(ss[i+p[i]]==ss[i-p[i]])p[i]++;
        if(p[i]+i>R){
            R=p[i]+i;
            C=i;
        }
    }
    return p;
    //回文半径减一是原串的回文长度
}
```

# 计算几何

## 凸包

### 浮点数

```cpp
const double pi = acos(-1);
const double eps =1e-8;

int Dcmp(double x,double y){
    if(fabs(x-y)<eps)return 0;
    return x<y?-1:1;
}

struct Point
{
    double x,y;
    Point(){}
    Point(double x,double y):x(x),y(y){}

    Point operator+(Point B){return Point(x+B.x,y+B.y);}
    Point operator-(Point B){return Point(x-B.x,y-B.y);}
    Point operator*(double k){return Point(x*k,y*k);}
    Point operator/(double k){return Point(x/k,y/k);}
    bool operator ==(Point B){return Dcmp(x,B.x)==0&&Dcmp(y,B.y)==0;}
    bool operator <(Point B){
        return Dcmp(x,B.x)<0||Dcmp(x,B.x)==0&&Dcmp(y,B.y)<0;}
};
typedef Point Vector;

double Cross(Vector A,Vector B){return A.x*B.y - A.y*B.x;}//叉积,小于零表示B在右边
double Distance(Point A,Point B){return hypot(A.x-B.x,A.y-B.y);}

vector<Point> Convex_hull(vector<Point>&p){
    sort(p.begin(),p.end());
    p.erase(unique(p.begin(), p.end()), p.end());

    int v=0;
    vector<Point>hull;
    for (int i = 0; i < p.size(); i++)
    {
        while(v>1 && Dcmp(Cross(hull[v-1]-hull[v-2],p[i]-hull[v-1]),0)<=0){hull.pop_back();v--;}
        hull.push_back(p[i]);
        v++;
    }
    int j=v;
    for (int i = p.size()-2; i >= 0; i--)
    {
        while(v>j && Dcmp(Cross(hull[v-1]-hull[v-2],p[i]-hull[v-1]),0)<=0){hull.pop_back();v--;}
        hull.push_back(p[i]);
        v++;
    }
    //if(p.size()>1)hull.pop_back();//要不要起始位置
    return hull;
}
```

### 整数

```cpp
struct Point
{
    long long x,y;
    Point(){}
    Point(long long x,long long y):x(x),y(y){}

    Point operator+(Point B){return Point(x+B.x,y+B.y);}
    Point operator-(Point B){return Point(x-B.x,y-B.y);}
    Point operator*(long long k){return Point(x*k,y*k);}
    Point operator/(long long k){return Point(x/k,y/k);}
    bool operator ==(const Point& B){return x==B.x&&y==B.y;}
    bool operator <(const Point& B){
        return x<B.x||x==B.x&&y<B.y;}
};
typedef Point Vector;

long long Cross(Vector A,Vector B){return A.x*B.y - A.y*B.x;}//叉积,小于零表示B在右边
long long Distance(Point A,Point B){return hypot(A.x-B.x,A.y-B.y);}

vector<Point> Convex_hull(vector<Point>p){
    
    p.erase(unique(p.begin(), p.end()), p.end());

    long long v=0;
    vector<Point>hull;
    for (long long i = 0; i < p.size(); i++)
    {
        while(v>1 && Cross(hull[v-1]-hull[v-2],p[i]-hull[v-1])<=0){hull.pop_back();v--;}
        hull.push_back(p[i]);
        v++;
    }
    long long j=v;
    for (long long i = p.size()-2; i >= 0; i--)
    {
        while(v>j && Cross(hull[v-1]-hull[v-2],p[i]-hull[v-1])<=0){hull.pop_back();v--;}
        hull.push_back(p[i]);
        v++;
    }
    //if(p.size()>1)hull.pop_back();//要不要起始位置
    return hull;
}
```

# 动态规划

## 背包

背包是一种常见的组合优化问题，指在给定的一些物品和一个固定大小的背包容量下，选择若干个物品放入背包中，使得背包能够承载的物品总价值最大（或最小）

### 01背包

具体来说，假设有一个可容纳重量为 W 的背包和 n 个物品，每个物品 i 都有一个重量 $w[i] $和一个价值 $v[i]$。现在要选择一些物品放入背包中，使得在不超过背包容量的前提下，背包中物品的总价值最大。

最基本的思路是使用动态规划，设$f[i][j]$表示在前 i 个物品中选择若干个物品放入容量为 j 的背包中所能得到的最大价值，则可以得到状态转移方程：

当j<w[i]时，$f[i][j]=f[i-1][j]$（即背包容量不足以放入物品 i，只能选择不放物品 i）； 当j>=w[i]时，$f[i][j]=max(f[i-1][j], f[i-1][j-w[i]]+v[i])$（即在不放入物品 i 的情况下，前 i-1 个物品已经占用了 j 的容量，而现在还剩下 j-w[i] 的容量可以放物品 i，此时选择放入物品 i，总价值为$ f[i-1][j-w[i]]+v[i]$）。
最后，$f[n][W]$就是在背包容量为 W 的情况下，能够得到的最大价值。

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int w[N], v[N], f[N]; // w[i] 表示第 i 个物品的重量，v[i] 表示第 i 个物品的价值，f[j] 表示在容量为 j 的背包中所能得到的最大价值。

int main() {
    int n, m;
    cin >> n >> m; // n 表示物品个数，m 表示背包容量
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }

    memset(f, 0, sizeof f); // 初始化为 0
    
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= w[i]; j--) {
            f[j] = max(f[j], f[j - w[i]] + v[i]); // 在不放入物品 i 的情况下，前 i-1 个物品已经占用了 j 的容量，而现在还剩下 j-w[i] 的容量可以放物品 i，此时选择放入物品 i，总价值为 f[j-w[i]]+v[i]。
        }
    }
 
    cout << f[m] << endl; // 输出最大价值
    return 0;
}
```

### 完全背包

完全背包是背包问题的一种变种，与 01 背包不同的是，在完全背包中，每个物品可以取无限次。

具体来说，给定 $n$ 种物品和一个容量为 $m$ 的背包，其中每种物品的重量为 $w_i$，价值为 $v_i$，每种物品都有无限件可用，问在背包容量有限的情况下，能够获得的最大价值是多少。

完全背包问题可以用动态规划来求解。我们仍然定义状态 $f(i,j)$ 表示前 $i$ 种物品，且总重量不超过 $j$ 的情况下，能够获得的最大价值。对于第 $i$ 种物品，它可以选取的次数为 $0$ 到 $\lfloor\frac{m}{w_i}\rfloor$，因此状态转移方程为：

$$f(i,j) = \max{f(i-1,j-k\times w_i)+k\times v_i}$$

其中，$0 \leq k \leq \lfloor\frac{m}{w_i}\rfloor$。

完全背包问题与 01 背包问题非常相似，它们的区别在于第 $i$ 个物品最多可选取 $m/w_i$ 个，因此需要对其状态转移方程进行一些修改。以下是完全背包问题的一份 C++ 代码实现：

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int w[N], v[N], f[N]; // w[i] 表示第 i 种物品的重量，v[i] 表示第 i 种物品的价值，f[j] 表示在容量为 j 的背包中所能得到的最大价值。

int main() {
    int n, m;
    cin >> n >> m; // n 表示物品个数，m 表示背包容量
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }

    memset(f, 0, sizeof f); // 初始化为 0
    
    for (int i = 1; i <= n; i++) {
        for (int j = w[i]; j <= m; j++) {
            for (int k = 0; k * w[i] <= j; k++) { // 枚举第 i 种物品的数量 k
                f[j] = max(f[j], f[j - k * w[i]] + k * v[i]); // 选择第 i 种物品 k 次，更新最大价值
            }
        } 
    }

    cout << f[m] << endl; // 输出最大价值
    return 0;
}
```

## 区间dp

$f(i,j)=\max_{i<=k<=j}{f(i，k)+f(k+1,j)+cost}$

```
for (int len = 2; len <= n; len++) {//先枚举区间长度
	for (int i = 1; i+len-1 <= n; i++) {//再枚举区间左端点，左端点加区间长度为右端点，不能大于n
		int j = i+len-1;	//区间右端点
		for (int k = i; k < j; k++) {	//枚举区间分割点
			dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[k+1][j]+合并区间的消耗);
		}
	}
}

```

## DAG上的dp（DAG上的最长最短路）

进行DAG上的DP之前，需要先对DAG进行拓扑排序，然后按拓扑排序进行dp，以保证在DP时每个节点的所有前驱节点已经被计算过

## 子段最大/小值

树上用倍增找LCA维护

```
#include "iostream"
#include "vector"
#include "cmath"
#include "array"
#define ll long long
using namespace std;
inline ll read() {ll x = 0, z = 1;char c = getchar();while (!isdigit(c)) {if (c == '-')z = -1;c = getchar();}while (isdigit(c)) {x = (x << 1) + (x << 3) + (c ^ 48);c = getchar();}return z * x;}

class info{
public:
    int mn=0,mx=0;
    int mnpre=0,mnsuf=0;
    int mxpre=0,mxsuf=0;
    int sum=0;
    info rev(){
        info x=*this;
        swap(x.mnsuf,x.mnpre);
        swap(x.mxpre,x.mxsuf);
        return x;
    }
};

//a是前端，b是后端 从前到后是a.pre,a.suf,b.pre,b.suf;
info operator+(const info&a,const info&b){
    info c;
    c.mnpre=min(a.mnpre,a.sum+b.mnpre);
    c.mnsuf=min(b.mnsuf,b.sum+a.mnsuf);

    c.mxpre=max(a.mxpre,a.sum+b.mxpre);
    c.mxsuf=max(b.mxsuf,b.sum+a.mxsuf);

    c.mn=min(min(a.mn,b.mn),a.mnsuf+b.mnpre);
    c.mx=max(max(a.mx,b.mx),a.mxsuf+b.mxpre);

    c.sum=a.sum+b.sum;
    return c;
}

int main(){
    int t=read();
    while(t--){
        int n=read();
        vector<int>fa(n+5),val(n+5);
        vector<array<int,3>>qur;
        int cnt=1;
        fa[cnt]=0,val[cnt]=1;
        for (int i = 0; i < n; ++i) {
            char c;
            cin>>c;
            if(c=='+'){
                cnt++;
                fa[cnt]=read();
                val[cnt]=read();
            }
            else{
                int x=read(),y=read(),k=read();
                qur.push_back({x,y,k});
            }
        }

        vector<int>dep(cnt+5);
        int mm= log2(cnt);
        vector<vector<int>>father(cnt+5,vector<int>(mm+1));
        //i的第2^j个父亲 fa[i][j]=fa[fa[i][j-1]][j-1];
        vector<vector<info>>st(cnt+5,vector<info>(mm+1));
        //段(i,i+2^j-1)的信息,(i,i+2^j-1)=(i,i+2^(j-1)-1)+(i+2^(j-1),i+2^(j-1)+2^(j-1)-1),st[i][j]=st[i][j-1]+st[fa[i][j-1]][j-1];

        //初始化
        for (int i = 1; i <= cnt; ++i) {
            dep[i]=dep[fa[i]]+1;
            father[i][0]=fa[i];
            if (val[i] == 1) {
                st[i][0].mx = st[i][0].mxpre = st[i][0].mxsuf = st[i][0].sum = 1;
            } else {
                st[i][0].mn = st[i][0].mnpre = st[i][0].mnsuf = st[i][0].sum = -1;
            }
        }

        //dp
        for (int j = 1; j <= mm; ++j) {
            for(int i=cnt; i>0;i--){
                father[i][j]=father[father[i][j-1]][j-1];
                st[i][j]=st[i][j-1]+st[father[i][j-1]][j-1];
            }
        }


        //lca的同时求路径子段信息
        auto query=[&](int x,int y)->info{
            if (dep[x] < dep[y]) swap(x, y);

            if(x==y)return st[x][0];

            info l,r;
            if(dep[x]!=dep[y]){
                for (int i = mm; i >= 0; --i) {
                    if(dep[father[x][i]]>dep[y]){l=l+st[x][i];x=father[x][i];}
                }
                l=l+st[x][0];
                x=father[x][0];
            }
            if(x==y)return l+st[x][0];

            for (int i = mm; i >= 0; i--)
            {
                if (father[x][i] != father[y][i])
                {
                    l=l+st[x][i];
                    r=r+st[y][i];
                    x = father[x][i];
                    y = father[y][i];
                }
            }
            l=l+st[x][0];
            r=r+st[y][0];
            x = father[x][0];
            y = father[y][0];
            return l+st[x][0]+r.rev();
        };

        for (auto q:qur) {
            int x=q.at(0),y=q.at(1),k=q.at(2);
            info ans=query(x,y);
            //cout<<ans.mn<<' '<<ans.mx<<endl;
            if(ans.mn<=k&&ans.mx>=k)cout<<"Yes"<<endl;
            else cout<<"No"<<endl;
        }
    }
}

```

# 技巧

很多关联值排序的时候可以排序下标，不用整合在一起

比如：

```cpp
        int q=read();
        vector<pii>ab(q);
        vector<int>e(q); 
        for (int i = 0; i < q; i++)
        {
            ab[i]={read(),read()};
            e[i]=read()+h[ab[i].first];//总能量
        }

        vector<int>p(q);//query的顺序
        iota(p.begin(),p.end(),0);
        sort(p.begin(),p.end(),
            [&](int i,int j){
                return e[i]<e[j];
            }
        );
```
